// Generated by CoffeeScript 1.7.1
(function() {
  var exports;

  exports = this;

  document.addEventListener('DOMContentLoaded', function() {
    exports.progressbarView = {
      el: {
        gaugeBox: document.getElementById('gauge-box'),
        background: document.getElementById('background-window'),
        arrowBox: document.getElementById('arrow-box'),
        tiles: document.getElementsByClassName('arrow-tile'),
        progress: document.getElementById('progress-bar')
      },
      _state: {
        full: false,
        model: {}
      },
      speed: {
        stop: 0,
        slow: 1,
        middle: 4,
        fast: 8
      },
      framerate: 16,
      progressbar: {
        currentSprite: 0,
        passingWidth: 0,
        recentWidth: 0,
        countTime: 0,
        settings: {
          durationTime: 1500,
          easing: 'easeOutExpo',
          tileSize: {
            width: 100,
            heigth: 20
          }
        }
      },
      display: {
        opacity: 0,
        countTime: 0,
        settings: {
          durationTime: 200,
          easing: 'easeOutSine'
        }
      },
      easing: {
        easeOutSine: function(t, b, c, d) {
          return c * Math.sin(t / d * (Math.PI / 2)) + b;
        },
        easeOutExpo: function(t, b, c, d) {
          if (t === d) {
            return b + c;
          } else {
            return c * (-Math.pow(2, -10 * t / d) + 1) + b;
          }
        }
      },
      initProgressbar: function() {
        this.progressbar.countTime = 0;
        this.progressbar.passingWidth = 0;
        this.progressbar.recentWidth = 0;
        this.el.progress.style.width = '0%';
        return this.changeState({
          full: false
        });
      },
      initDisplay: function() {
        return this.display.countTime = 0;
      },
      progressbarUpdate: function() {},
      makeProgressbarUpdate: function() {
        var arrowboxStyle, duration, easing, frame, framerate, model, progressbar, progressbarStyle, settings, tileHeight, tileWidth, tiles, _genPosition, _renderRatio;
        model = this._state.model;
        framerate = this.framerate;
        progressbar = this.progressbar;
        settings = progressbar.settings;
        tileWidth = settings.tileSize.width;
        tileHeight = settings.tileSize.heigth;
        duration = settings.durationTime / framerate | 0;
        easing = this.easing[settings.easing];
        tiles = this.el.tiles;
        progressbarStyle = this.el.progress.style;
        arrowboxStyle = this.el.arrowBox.style;
        frame = 0;
        _renderRatio = (function(_this) {
          return function() {
            progressbar.countTime = 0;
            progressbar.recentWidth = model.progress * 100;
            progressbar.passingWidth = progressbarStyle.width.replace('%', '') | 0;
            return _this.fire('ratiorendered', null);
          };
        })(this);
        _genPosition = function(current) {
          return "" + (current % 4 * -tileWidth) + "px " + ((current / 4 | 0) * -tileHeight) + "px";
        };
        return this.progressbarUpdate = (function(_this) {
          return function() {
            var v, _i, _len;
            if (++frame % 2 === 0) {
              for (_i = 0, _len = tiles.length; _i < _len; _i++) {
                v = tiles[_i];
                v.style.backgroundPosition = _genPosition(progressbar.currentSprite);
              }
              progressbar.currentSprite = ++progressbar.currentSprite % 28;
            }
            if (frame % 50 === 0) {
              if (model.canRenderRatio) {
                _renderRatio();
              }
              if (model.canQuit && progressbarStyle.width === '100%') {
                _this.changeState({
                  full: true
                });
              }
            }
            if (progressbar.countTime <= duration) {
              progressbarStyle.width = easing(progressbar.countTime++, progressbar.passingWidth, progressbar.recentWidth - progressbar.passingWidth, duration) + '%';
            }
            frame %= 100;
            return arrowboxStyle.left = "" + (frame * _this.speed[model.flowSpeed] % 100 - 100) + "px";
          };
        })(this);
      },
      fadingUpdate: function() {},
      makeFadingUpdate: function() {
        var backgroundStyle, display, duration, easing, frame, framerate, gaugeboxStyle, model, settings;
        model = this._state.model;
        framerate = this.framerate;
        display = this.display;
        settings = display.settings;
        duration = settings.durationTime / framerate | 0;
        easing = this.easing[settings.easing];
        gaugeboxStyle = this.el.gaugeBox.style;
        backgroundStyle = this.el.background.style;
        frame = 0;
        this.makeFadingUpdate = (function(_this) {
          return function() {
            var currentOpacity, targetOpacity, type;
            type = model.fading;
            currentOpacity = display.opacity;
            switch (type) {
              case 'stop':
                return;
              case 'in':
                targetOpacity = 1;
                break;
              case 'out':
                targetOpacity = 0;
            }
            return _this.fadingUpdate = function() {
              display.opacity = easing(display.countTime, currentOpacity, targetOpacity - currentOpacity, duration);
              gaugeboxStyle.opacity = display.opacity * 0.5;
              backgroundStyle.opacity = display.opacity * 0.8;
              if (display.countTime >= duration) {
                display.opacity = targetOpacity;
                if (model.fading === 'out') {
                  _this._displayChange('none');
                }
                _this.fire('fadeend');
                _this.initDisplay();
                return;
              }
              return display.countTime++;
            };
          };
        })(this);
        return this.makeFadingUpdate();
      },
      fadeInOut: function(statusObj) {
        if (statusObj.fading === 'in') {
          this._displayChange('block');
        }
        return this.makeFadingUpdate();
      },
      _displayChange: function(prop) {
        this.el.gaugeBox.style.display = this.el.background.style.display = prop;
        return this.fire('hide', null);
      }
    };
    makePublisher(progressbarView);
    return makeStateful(progressbarView);
  });

}).call(this);
